var tipuesearch = {"pages":[{"title":"About","text":"CCNY_Prep This is a Blog meant to keep track of our interview preparation progress. This GitHub Pages blog relies on: - travis-ci.org for automating the update and generation process - ‘pelican' for static rendering of your blog from the markdown or asciidoc articles - ‘Elegant' for the ‘Theme' - peru for automating repository upgrades for plugins, etc - blog-o-matic Setup First, clone the repo. 1 git clone https://github.com/dahadaller/dahadaller.github.io.git Then, checkout the source branch. You will be working exclusively in this branch. 1 git checkout source Posting to Blog Each member of the group has a designated folder in the content/ directory. Any markdown files placed in this directory will be turned into blog posts. 1 2 3 4 5 dahadaller.github.io/content ├── Alex ├── Angelique ├── David └── Kieran Once you've written your new article in your content subfolder, perform: 1 2 3 4 5 6 7 8 ## Add file to repository git add content/<your_name_here> ## Add file to commit git commit -m \"Added my new article\" ## Upload changes to github git push After some seconds, - travis-ci build the site with Pelican and commit the resultant html files to the master branch of this repo. After that, GitHub Pages will make the updated blog available at dahadaller.github.io . Blog Post Format Generally, blog posts can be about any topic you think would be helpful to the group, and can be written in any way you choose. However, blog posts that are in response to the weekly excercises need to have certain headers in the YAML preamble so that Pelican can categorize them correctly on the final site. For example, a post made in response to Week 1 Excercises would have a YAML headers like this: 1 2 3 4 5 6 7 8 Title : David ' s Week 1 Excercises Date : 2020 - 05 - 09 11 : 15 Authors : David Hadaller Tags : Week 1 ### Subtitle Rest of my post continues ...","tags":"pages","url":"/about/","loc":"/about/"},{"title":"UMPIRE","text":"For any problem — whether in interviews, or studying — one must always create a plan of attack. The UMPIRE method is one way to create such a plan, and find your solution. It's especially helpful when you're completely lost as to how to solve a given problem. The UMPIRE Method: Understand what the interviewer is asking for by using test cases and questions about the problem. Match what this problem looks like to known categories of problems, e.g. Linked List or Dynamic Programming and strategies or patterns in those categories. Plan the solution with appropriate visualizations and pseudocode. Implement the code to solve the algorithm. Review the code by running specific example(s) and recording values (watchlist) of your code's variables along the way. Evaluate the performance of your algorithm and state any strong/weak or future potential work. UMPIRE helps you organize your thoughts to avoid getting stuck in an interview. Also, even though it might seem like a drawn out process, it will help solve problems faster than jumping in without a plan. Also, when you dive in to coding the answer to the problem right away, the consequences are as follows: The interviewer will think you isolate yourself when you solve problems. Translation: you won't be able to work on a team effectively. You will miss out on valuable hints. Part of UMPIRE is opening dialogue with the interviewer. The interviewer cannot help you if they don't know your thought process ABS ( ALWAYS BE SPEAKING ) You may find yourself at a dead end with 10 minutes remaining, and you will then scremble to reorganize your approach. If you tell the interviewer your plan beforehand, as is done in UMPIRE , the interviewer can guide you in the right direction, and prevent you from going down that path. UNDERSTAND : One of the best ways to understand a problem is to come up with test cases. Coming up with good test cases can be an art, but I typically like to cover one happy path or an average case. And any interesting edge cases. This can be tricky as it depends on the problem. Remember that the interview is a dialogue, so understanding the problem is best done as a dialog as well. Asking questions, like Should this be done in place?… Does the ordering beyond the left/right of the partition matter? Create simple test cases and try to talk with your interviewer to see if they believe you get the idea. NEVER leave any stones unturned, keep asking until you perfectly understand the questions!!! MATCH : Once you understand, try to match algorithms/data-structures to the question. For example, if the answer involves a sort maybe try using a priority queue. If the answer needs a certain order, try a stack or a list. Told to search in a sorted list, BINARY SEARCH should be the first thing that hits your head, a two-pointer approach should be second. You get the idea. PLAN : This is where you try your ideas. I cannot stress enough to write out your logic in sentences and then pseudo code it. Interviewers need at least a pseudo code form just in case you can't code the question for real. Sometimes its ok if you can't code it completely, if they can understand your logic and know in general you can code with more resources… its good enough. I like to write a complete pseudo code in leetcode on top of the given function. Many times this has led me to writing the real code in 2-3 minutes! DO NOT FORGET EDGE CASES , what if your input is null or size of 1? The better you plan the more your interviewer will be impressed. You can also discuss the run/space complexity with the interviewer if your 100% sure it's right. Up to this point try to aim to leave the plan stage within 8-10 minutes. The next stage should take up most of the rest of the time. IMPLEMENT : If our plan stage was successful, we should be able to implement the code by simply gluing the plan together while filling out the details of our language specific implementation. If your pseudo code is strong, this part should be a breeze. If you ever get stuck, your plan is already made so there's A LOT less thinking and MORE doing! Remember the CPU reference before? If you didn't plan and got stuck implementing, now your brain is processing and retrieving memory at the same time. This is how you burn out quickly! Use your pseudo code as a CPU CACHE !!! Quick small retrieval if necessary, to process that plan efficiently! If you still get stuck this is where you ask for hints or stop completely for 1-2 minutes to think. EVALUATE : The last step of the UMPIRE strategy is to discuss the pros and cons of your algorithm with your interviewer. An algorithm much like a good interview is not amenable to correct/incorrect label, instead there are often things to discuss about what you like about your algorithm or code and what you would like to change depending on conditions, inputs, expectations, the business, etc. A great place to start this conversation and is almost always required is to discuss the asymptotic performance of the algorithm. Always remember, everyone always starts at the bottom of the ladder. Its tough at first but eventually you'll notice patterns. When you do, that's when you activate god mod. If a problem is tough, spend 1 hour thinking the best solution or part of it. Then check the answer and spend the time looking at different solutions/understanding it line by line! Remember treat your brain only as a CPU AND ABS !!!","tags":"pages","url":"/umpire/","loc":"/umpire/"},{"title":"Week 5 Excercises","text":"Goals Understand various graph representations Recognize problems that can be solved with graphs Know how to quickly implement graph searches ( BFS , DFS ) Recognize topological sort graph problems Keep in mind that during interviews coding questions are usually allotted 30-40 minutes. Given that time constraint, you should aim to spend around 15-20 minutes on each problem. So, figure out how to work through a particular class of problems, and then revisit them later on to cut down the time you spend on each problem. Tuesday Read the following articles and watch the youtube playlist that walks through graph problems. Graphs · codepath/compsci_guides Wiki Graph Traversals · codepath/compsci_guides Wiki Topological Sort · codepath/compsci_guides Wiki Detect Cycle in Directed Graph - YouTube Thursday Sum of dependencies in a graph - GeeksforGeeks Number of sink nodes in a graph - GeeksforGeeks Saturday Is Graph Bipartite? - LeetCode Minimum Height Trees - LeetCode Clone Graph - LeetCode Other Problems Evaluate Division - LeetCode Kth Smallest Element in a BST - LeetCode Lowest Common Ancestor of a Binary Tree - LeetCode Journey to the Moon | HackerRank Other Resources (This section covers algorithms that will come up less frequently in interviews.) - Union Find, Disjoint Sets Guide - Union Find, Disjoint Sets Interview question bank - Shortest Paths Algorithms Guide - Shortest Paths Algorithms Interview Question Bank - Minimum Spanning Trees Guide - Minimum Spanning Trees Interview Question Bank","tags":"Weekly Lessons","url":"/blog/2020/06/16/week-5-excercises/","loc":"/blog/2020/06/16/week-5-excercises/"},{"title":"112 Path Sum (David)","text":"Here I solve the Path Sum - LeetCode problem from LeetCode: Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22 , 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22. The approach taken here is that we do a postorder traversal (because we're looking for paths that end in leaves) As we go, we subtract the current node value from the path sum as we encounter new nodes. If the current node is a leaf node, and the path_sum is 0, then we know that all the nodes on the way to the current add up to the orignial path_sum before subtraction began. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def hasPathSum ( self , root : TreeNode , path_sum : int ) -> bool : # base case for stop traversal if not root : return False # base case for search: it has to be a path to a leaf. # omitting the leaf restriction means you look for paths of length k # ending at any arbitrary node. elif not root . left and not root . right and path_sum - root . val == 0 : return True # postorder traversal inductive step else : left_path_has_sum = self . hasPathSum ( root . left , path_sum - root . val ) right_path_has_sum = self . hasPathSum ( root . right , path_sum - root . val ) root_path_hast_sum = left_path_has_sum or right_path_has_sum return root_path_hast_sum","tags":"David","url":"/blog/2020/06/09/112-path-sum-david/","loc":"/blog/2020/06/09/112-path-sum-david/"},{"title":"202 Happy Number (David)","text":"Here we solve the Happy Number Problem from LeetCode. Write an algorithm to determine if a number n is \"happy\". A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Return True if n is a happy number, and False if not. Example: Input: 19 Output: true Explanation: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 The trick to this problem is you have to keep a record of the happy numbers already encountered, and you have to be able to iterate through the individual digits of a number. In this approach, I used a set previous_numbers to keep track of the happy numbers that have already been calculated. I also converted the numbers to strings, since strings are iterable by character in Python (each character being a digit in this case) , instead of using // and % . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def isHappy ( self , n : int ) -> bool : current_number = str ( n ) previous_numbers = set () while current_number != '1' : square_sum = 0 for digit in map ( int , list ( str ( current_number ))): square_sum += digit * digit current_number = str ( square_sum ) if current_number not in previous_numbers : previous_numbers . add ( current_number ) else : return False return True","tags":"David","url":"/blog/2020/06/09/202-happy-number-david/","loc":"/blog/2020/06/09/202-happy-number-david/"},{"title":"232 Implement Queue using Stacks (David)","text":"This post solves the Implement Queue using Stacks - LeetCode problem. Implement the following operations of a queue using stacks. push(x) — Push element x to the back of queue. pop() — Removes the element from in front of queue. peek() — Get the front element. empty() — Return whether the queue is empty. Example: \" ` MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // returns 1 queue.pop(); // returns 1 queue.empty(); // returns false \"` Notes: You must use only standard operations of a stack — which means only push to top , peek/pop from top , size , and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). While in a queue there are two points of ingress and egress, stacks only have one. You can leave from the front of the queue, and enter from the back, but you can only enter and exit from the top of the stack. This solution is optimized for multiple pushes/pops in a row. Whenever we want to push to the queue, all data is placed in the push_stack , where the front of the queue corresponds to the bottom of the push_stack and the back of the queue corresponds to the top of the stack. Then, each subsequent push operation after the first one only takes O(1), since we're just pushing to the end of the stack. Whenever we want to pop from the front of the queue, we migrate all the data to the pop_stack where it will be in reverse order compared to the push_stack . The top of the pop_stack corresponds to the front of the queue, so popping off the front takes O(1) just like a normal stack pop. So, the runtime complexity of pushing/popping to the queue are O(n) in the worst case and O(1) in the average case. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class MyQueue : def __init__ ( self ): \"\"\" Initialize your data structure here. \"\"\" # holds data for queue pushing is O(1) but popping is O(N) because # beginning of queue is at bottom of stack in this implementation self . push_stack = [] self . pop_stack = [] def push ( self , x : int ) -> None : \"\"\" Push element x to the back of queue. \"\"\" if not self . push_stack : while self . pop_stack : self . push_stack . append ( self . pop_stack . pop ()) self . push_stack . append ( x ) def pop ( self ) -> int : \"\"\" Removes the element from in front of queue and returns that element. \"\"\" if not self . pop_stack : while self . push_stack : self . pop_stack . append ( self . push_stack . pop ()) return self . pop_stack . pop () def peek ( self ) -> int : \"\"\" Get the front element. \"\"\" if not self . pop_stack : while self . push_stack : self . pop_stack . append ( self . push_stack . pop ()) return self . pop_stack [ - 1 ] def empty ( self ) -> bool : \"\"\" Returns whether the queue is empty. \"\"\" q_len = max ( len ( self . push_stack ), len ( self . pop_stack ) ) return q_len == 0 # Your MyQueue object will be instantiated and called as such: # obj = MyQueue() # obj.push(x) # param_2 = obj.pop() # param_3 = obj.peek() # param_4 = obj.empty()","tags":"David","url":"/blog/2020/06/09/232-implement-queue-using-stacks-david/","loc":"/blog/2020/06/09/232-implement-queue-using-stacks-david/"},{"title":"36 Valid Sudoku (David)","text":"Here we solve the Valid Sudoku Problem from LeetCode. Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules : Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character '.' . Example 1: Input: [ [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"], [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"], [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"], [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"], [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"], [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"], [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"], [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"], [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"] ] Output: true Example 2: Input: [ [\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"], [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"], [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"], [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"], [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"], [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"], [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"], [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"], [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"] ] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character '.' . The given board size is always 9x9 . This solution holds all data in a set called big instead of using separate data structures for the rows, columns and boxes. Rows that already have a given number are placed in big as (row, cell) tuples, where cell is the number the row already contains. Columns reverse the tuple order with (cell, col) tuples. And the boxes use integer division to find the value of the nearest upper-left-hand corner with row//3 and col//3 . This means that the 3-tuple (row//3, col//3, cell) associates each number in cell with the closest upper-left-hand corner. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def isValidSudoku ( self , board : List [ List [ str ]]) -> bool : big = set () for row in range ( 0 , 9 ): for col in range ( 0 , 9 ): if board [ row ][ col ] != '.' : cell = board [ row ][ col ] if ( row , cell ) in big or ( cell , col ) in big or ( row // 3 , col // 3 , cell ) in big : return False big . add (( row , cell )) big . add (( cell , col )) big . add (( row // 3 , col // 3 , cell )) return True","tags":"David","url":"/blog/2020/06/09/36-valid-sudoku-david/","loc":"/blog/2020/06/09/36-valid-sudoku-david/"},{"title":"373 Find K Pairs with Smallest Sums (David)","text":"Here we solve the Find K Pairs with Smallest Sums problem from LeetCode: You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k . Define a pair (u,v) which consists of one element from the first array and one element from the second array. Find the k pairs (u1,v1),(u2,v2) …(uk,vk) with the smallest sums. Example 1: Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output: [[1,2],[1,4],[1,6]] Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] Example 2: Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2 Output: [1,1],[1,1] Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] Example 3: Input: nums1 = [1,2], nums2 = [3], k = 3 Output: [1,3],[2,3] Explanation: All possible pairs are returned from the sequence: [1,3],[2,3] I'm not sure if there's a more efficient solution to this problem. What I have done hear is produce a list of all possible n1 , n2 combinations and their sums, and heapified the list by the sum. Then I pop k elements off the heap. This runs in O(n&#94;2), but I couldn't think of a way to do it quicker. 1 2 3 4 5 6 7 8 9 10 11 12 import heapq class Solution : def kSmallestPairs ( self , nums1 : List [ int ], nums2 : List [ int ], k : int ) -> List [ List [ int ]]: if not nums1 or not nums2 : return [] heap = [( n1 + n2 , n1 , n2 ) for n1 in nums1 for n2 in nums2 ] heapq . heapify ( heap ) l = len ( heap ) if k > len ( heap ) else k return [ heapq . heappop ( heap )[ 1 :] for _ in range ( l )]","tags":"David","url":"/blog/2020/06/09/373-find-k-pairs-with-smallest-sums-david/","loc":"/blog/2020/06/09/373-find-k-pairs-with-smallest-sums-david/"},{"title":"404 Sum of Left Leaves (David)","text":"Here we solve the Sum of Left Leaves - LeetCode problem from LeetCode: Find the sum of all left leaves in a given binary tree. Example: \" ` 3 / \\ 9 20 / \\ 15 7 There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. \"` This is an interesting problem in that the solution requires some labeling (the comments below) to recognize the base case, and the recursive postorder traversal. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def sumOfLeftLeaves ( self , root : TreeNode ) -> int : # base case for stopping traversal if not root : return 0 # base case for adding the left leaf value # (notice that this base case also has a recursive call onto the # right sub tree) elif root . left and not root . left . left and not root . left . right : return root . left . val + self . sumOfLeftLeaves ( root . right ) # this is the recursive step and it is a postorder traversal of the # binary tree compressed into a single line else : return self . sumOfLeftLeaves ( root . left ) + self . sumOfLeftLeaves ( root . right ) # the code could also be written as follows to demonstrate that it is postorder: # left_sum = self.sumOfLeftLeaves(root.left) # right_sum = self.sumOfLeftLeaves(root.right) # root_sum = left_sum + right_sum # return root_sum","tags":"David","url":"/blog/2020/06/09/404-sum-of-left-leaves-david/","loc":"/blog/2020/06/09/404-sum-of-left-leaves-david/"},{"title":"692 Top K Frequent Words (David)","text":"Here we solve the Top K Frequent Words from LeetCode. Given a non-empty list of words, return the k most frequent elements. Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first. Example 1: Input: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2 Output: [\"i\", \"love\"] Explanation: \"i\" and \"love\" are the two most frequent words. Note that \"i\" comes before \"love\" due to a lower alphabetical order. Example 2: Input: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4 Output: [\"the\", \"is\", \"sunny\", \"day\"] Explanation: \"the\", \"is\", \"sunny\" and \"day\" are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively. Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Input words contain only lowercase letters. Follow up: Try to solve it in O ( n log k ) time and O ( n ) extra space. This is a simple problem if you know that heaps are built in O(n) and that the Counter() class allows us to easily keep count of frequent elements in python. First we create the word_freq counter dictionary for word frequency, after which we create a list of tuples; we heapify this list into a min heap (negating freq with -freq allows us to sort like a max heap). After this, we return only the first k elements of the heap. The overall runtime complexity is O(k + 3n) where n is the length of the words list. 1 2 3 4 5 6 7 8 9 10 11 from collections import Counter import heapq class Solution : def topKFrequent ( self , words : List [ str ], k : int ) -> List [ str ]: word_freq = Counter ( words ) heap = [( - freq , word ) for word , freq in word_freq . items ()] heapq . heapify ( heap ) return [ heapq . heappop ( heap )[ 1 ] for _ in range ( k )]","tags":"David","url":"/blog/2020/06/09/692-top-k-frequent-words-david/","loc":"/blog/2020/06/09/692-top-k-frequent-words-david/"},{"title":"Week 4 Excercises","text":"Goals Know how to search for values in binary search tree in optimal way Understand and be able to implement the following types of traversals, including when to use them and their tradeoffs In-order, pre-order, post-order BFS DFS Understand how to implement at least one traversal in iterative approach Understand the concept of augmented trees and when they can be useful Monday Binary Trees · codepath/compsci_guides Wiki Binary Trees Iterative Traversal Design Pattern Binary Trees 2nd Largest Node Desogn Pattern Wednesday Invert Binary Tree - LeetCode Symmetric Tree - LeetCode Balanced Binary Tree - LeetCode Validate Binary Search Tree - LeetCode Binary Tree Pruning - LeetCode Kth Smallest Element in a BST - LeetCode Saturday Binary Tree Level Order Traversal II - LeetCode Minimum Depth of Binary Tree - LeetCode Flatten Binary Tree to Linked List - LeetCode Find Duplicate Subtrees - LeetCode Bonus Subtree of Another Tree - LeetCode Most Frequent Subtree Sum - LeetCode Convert Sorted Array to Binary Search Tree - LeetCode Print a Binary Tree in Vertical Order | Set 1 - GeeksforGeeks Path Sum - LeetCode Minimum Depth of Binary Tree - LeetCode Flatten Binary Tree to Linked List - LeetCode","tags":"Weekly Lessons","url":"/blog/2020/06/07/week-4-excercises/","loc":"/blog/2020/06/07/week-4-excercises/"},{"title":"84 Largest Rectangle in Histogram (David)","text":"This post is an in-depth explanation of the Largest Rectangle in Histogram problem from LeetCode based on this solution by user dietpepsi : Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3] . The largest rectangle is shown in the shaded area, which has area = 10 unit. Example: Input: [2,1,5,6,2,3] Output: 10 This problem can be solved with a stack approach with O(n) time complexity. Parentheses-matching problems are commonly solved with stack-based approaches, and they are intuitive to understand. So, it can be useful to think of the Largest Rectangle in Histogram problem as an instance of a parentheses-matching problem, only instead of parentheses, you will match certain histogram bars. All rectangular areas in the histogram have one thing in common; they are book-ended by two bars (one on the right side, and one on the left side) which are smaller than the middle bars. In the example above, histogram bars with height 5 and 6 are caught between bars with height 1 and 2, thus forming a 5x2=10 rectangular area. Traverse the histogram and add bar indices to the stack. In the code below, we traverse the histogram from left to right (→) in a for loop, adding a histogram's bar index to the stack whenever the height of the current bar in the for loop is greater than or equal to the bar already on the stack. So, bars placed on the stack will be increasing or staying the same in terms of height; this property is necessary to because the rectangle areas with the height of the smaller bars on the left can extend into the taller bars on the right (see gray rectangle in step 6 shown below for a reference image.) Stop traversing when you find a bar smaller than your previous bar. The parsing, i.e. the for loop, must stop as soon as the height of the bars decreases. A decreasing histogram bar constitutes our \"right parentheses\" and the previous smallest bar consitutes our left parentheses. At that point, where we encounter our \"right parentheses\" we enter a while loop to find the rectangular areas under the histogram bars we've been accumulating in the stack. The bars on the stack will only be those that are between our left and right parentheses bars. Calculate the area under that portion of the histogram after you stop the for loop. We pop data off the stack and calculate the maximum area in the body of the while loop below. In the body of the while loop, i remains fixed, while stack[-1] represents an index farther and farther to the left as items are popped off the stack. The effect is that the smaller-height bars encountered earlier in the parsing have a greater width than the taller bars encountered later (again, see step 6 in the image below for reference.) In treating the histogram as a parentheses-matching problem, it becomes necessary to establish outer-most \"parentheses\" represented by the dummy bars with height zero at indices -1 and 6. These dummy bars allow us to find the width of the histogram area under consideration when we consider the leftmost or rightmost histogram bars on the plot. These parentheses exist The variable ans stores the height of largest area encountered so far. So, ans = max(ans, h * w) finds whether the previous maximum rectangular area, ans , or the current rectangular area under consideration, h * w , is greater and assigns ans to that greater value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def largestRectangleArea ( self , height ): height . append ( 0 ) stack = [ - 1 ] ans = 0 # traverse the histogram and add bar indices to the stack for i in range ( len ( height )): # whenever you encounter a bar smaller than the previous bar, # stop traversing (and perform the while loop) while height [ i ] < height [ stack [ - 1 ]]: # calculate the area under that portion of the histogram h = height [ stack . pop ()] w = i - stack [ - 1 ] - 1 ans = max ( ans , h * w ) stack . append ( i ) height . pop () return ans","tags":"David","url":"/blog/2020/06/04/84-largest-rectangle-in-histogram-david/","loc":"/blog/2020/06/04/84-largest-rectangle-in-histogram-david/"},{"title":"Week 3 Excercises","text":"Goals Practice time and space complexity analysis Get comfortable with problem identification Review linked lists, hash table, stacks, queues, heaps problems Wednesday Trapping Rain Water II - LeetCode Largest Rectangle in Histogram - LeetCode Smallest Range I - LeetCode Thursday Sort Characters By Frequency - LeetCode Daily Temperatures - LeetCode 4Sum - LeetCode Read time complexity articles: Big O Complexity Analysis · codepath/compsci_guides Wiki Big O Notation | Interview Cake Logarithms for algorithmic coding interviews | Interview Cake Saturday Work through the time complexity problems from Interview Bit . Do as many problems as you can in these sections: basic primer math compare functions After that, we will work through the following problems using UMPIRE Evaluate Reverse Polish Notation - LeetCode Trapping Rain Water - LeetCode Talk through problems - Select one person to code the solution and rotate for the next question. The other person should work with the coder to come up with a solution. This isn't just about getting a correct solution but also effective communication. Come up with a few new example input/ outputs Talk about the edge cases Talk about different approaches Pseudocode Code the solution (talk throughout this segment!) Test your solution After completing a problem, scroll down to the bottom of this tab to find the solution links and discuss/compare your solution with the solution given. Is the one you've developed less efficient or less concise? Repeat this and work through the exercises below.","tags":"Weekly Lessons","url":"/blog/2020/06/02/week-3-excercises/","loc":"/blog/2020/06/02/week-3-excercises/"},{"title":"Week 2 Excercises","text":"Goals This week we will be covering the fundamentals of hash tables, heaps, stacks, and queues and common ways they appear in interviews. Test understanding of run times of each data structure Being able to identify the proper data structure to use Familiarity with hash tables, heaps, queues, stacks Learning how to better communicate in an interview setting Tuesday Jewels and Stones - LeetCode Valid Sudoku - LeetCode Thursday Do the following readings (important): Hash Tables · codepath/compsci_guides Wiki Heaps · codepath/compsci_guides Wiki Stacks and Queues · codepath/compsci_guides Wiki And solve the following problems: Implement Queue using Stacks - LeetCode Find Median from Data Stream - LeetCode Isomorphic Strings - LeetCode Happy Number - LeetCode Saturday Top K Frequent Words - LeetCode Find K Pairs with Smallest Sums - LeetCode Top K Frequent Words Walkthrough - YouTube","tags":"Weekly Lessons","url":"/blog/2020/05/26/week-2-excercises/","loc":"/blog/2020/05/26/week-2-excercises/"},{"title":"200 Number of Islands (Kieran)","text":"Given a 2d grid map of ‘1's (land) and ‘0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution : grid = list () def dfs ( self , x , y ): if self . grid [ x ][ y ] == '0' : return self . grid [ x ][ y ] = '0' if x - 1 >= 0 : self . dfs ( x - 1 , y ) if x + 1 < len ( self . grid ): self . dfs ( x + 1 , y ) if y - 1 >= 0 : self . dfs ( x , y - 1 ) if y + 1 < len ( self . grid [ x ]): self . dfs ( x , y + 1 ) def numIslands ( self , local_grid : List [ List [ str ]]) -> int : self . grid = local_grid count = 0 for i in range ( 0 , len ( self . grid )): for j in range ( 0 , len ( self . grid [ i ])): if self . grid [ i ][ j ] == '1' : count += 1 #print(f'{self.grid[0]}\\n{self.grid[1]}\\n{self.grid[2]}\\n{self.grid[3]}\\n') self . dfs ( i , j ) return count","tags":"Kieran","url":"/blog/2020/05/18/200-number-of-islands-kieran/","loc":"/blog/2020/05/18/200-number-of-islands-kieran/"},{"title":"543 Diameter of Binary Tree (Kieran)","text":"Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution : def height ( self , root : TreeNode ) -> int : if root is None : return 0 else : return 1 + max ( self . height ( root . left ), self . height ( root . right )) def diameterOfBinaryTree ( self , root : TreeNode ) -> int : if root is None : return 0 else : lheight = self . height ( root . left ) rheight = self . height ( root . right ) ldiam = self . diameterOfBinaryTree ( root . left ) rdiam = self . diameterOfBinaryTree ( root . right ) return max ( lheight + rheight , ldiam , rdiam )","tags":"Kieran","url":"/blog/2020/05/18/543-diameter-of-binary-tree-kieran/","loc":"/blog/2020/05/18/543-diameter-of-binary-tree-kieran/"},{"title":"Bloomberg Excercises","text":"User raptor16 from leetcode compiled the following list of Bloomberg's phone interview questions (original can be found here ): Monday Diameter of Binary Tree Number of Islands Two Sum Given a string print all subsets (not permutations) Two City Scheduling Electronic Exchange. You work in an electronic exchange. Throughout the day, you receive ticks (trading data) which consists of product name and its traded volume of stocks. Eg: {name: vodafone, volume: 20}. What data structure will you maintain if: You have to tell top k products traded by volume at end of day. You have to tell top k products traded by volume throughout the day. Insert Delete GetRandom o(1) Design a data structure with requirements: You have a structured input data for all objects Where you have Insert : O(1) Lookup : O(1) Delete : O(1) You can traverse the added elements in the order they were inserted. Similar to https://leetcode.com/problems/insert-delete-getrandom-o1/ 1D candy crush Remove parentheses Given a string of parentheses: s = \"()(()()()()())\" Remove the minimum amount of parentheses to make the string parentheses balanced in-place LRU Cache Wednesday Decode String Valid Anagram Palindrome Number Optimize from O(N) to O(log N) time complexity. Flatten a multilevel doubly linked list Output data from a stream in order Input: (1, \"abcd\"), (2, \"efgh\"), (4, \"mnop\"), (5, \"qrst\"), (3, \"ijkl\") Write a program to output the data from the stream in realtime in order, so 1,2,3,4,5.. You cannot queue up the incoming data from the stream. So for example if the first incoming bit of data is (1, \"abcd\"), and the second is (4, \"mnop\"), you cannot output (4, \"mnop\") until you get 2, 3. Find the minimum steps to generate a number given only two operations ( BFS ) https://leetcode.com/discuss/interview-question/329221/Bloomberg-or-Phone-screen-or-Software-Development-Internship-2019 Reorder array based on dictionary Similar to Reconstruct Itinerary Saturday Word Break II Subsets Longest Substring without repeating characters Flatten Linked List or First Unique Element File Diffs with RAM Constraints Remove array elements in given index ranges Right side view and Word Search: This is the question I (the author) got on my phone interview today. Nov 10 2019. I got 2 Leetcode medium questions with 5 minutes for questions and 5 minute for introductions, leaving 35 minutes for the coding portion. We discussed my past experience and he probled in deeper to see if I did have a good understanding of the tech stack that was used by my previous internship. LC Medium: Right side view of a binary tree They expected this code to compile and be tested out to be completely bug free, so you need to write the test cases yourself. LC Medium: Word Search I The interviewer did not expect this code to compile, so long as the general idea is correct you are good. You are expected to manually run through your code using their example. More under the interview experience section of leetcode Why Bloomberg OOP Questions Discuss the difference between Python, Java, and Javascript LC : Intersection of two linked list x2 Check if two linked lists intersect and return the intersecting point LC : Candy Crush LC : Merge Intervals LC : Add two numbers LC : Interleaving strings Implement a vector in C++ (use dynamic array approach) LC : Insert delete getrandom o(1) Occurence sort: given a string sort the string based on the number of times a letter appears in the string from most occurring to least occurring. For letters having the same occurrence sort based on lexicographical order LC : Trapping rain water LC Two sum Iterative and Recursive BS LC 3Sum Onsite (ignore for now) Definition of a Binary Search Tree followed by a coding question on finding the kth largest element in a binary search tree","tags":"Weekly Lessons","url":"/blog/2020/05/17/bloomberg-excercises/","loc":"/blog/2020/05/17/bloomberg-excercises/"},{"title":"328 Odd Even Linked List (David)","text":"This post solves the Odd Even Linked List problem from LeetCode. Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1->2->3->4->5->NULL Output: 1->3->5->2->4->NULL Example 2: Input: 2->1->3->5->6->4->7->NULL Output: 2->3->6->7->1->5->4->NULL Note: The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on … 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def oddEvenList ( self , head : ListNode ) -> ListNode : if not head : return odds_list = head evens_list = head . next trail_ptr = head lead_ptr = head . next trail_ptr_index = 1 while lead_ptr : # for each list element, make it point # to the next element over # +-----+ # | | # | v # 1 2->3->4->5->NULL # | | # tr lead_ptr trail_ptr . next = lead_ptr . next old_trail_ptr = trail_ptr trail_ptr = lead_ptr lead_ptr = lead_ptr . next trail_ptr_index += 1 # the following if statements are needed because the # trail_ptr (abbreviated tr in diagrams) falls on odd/even # list element at the end of the while loop depending on whether the total # number of elements (list index) is odd or even # 1->2->3->4->5->NULL (tr falls on odd) # | | | # old_tr tr lead_ptr # 1->2->3->4->5->6->NULL (tr falls on even) # | | | # old_tr tr lead_ptr if trail_ptr_index % 2 == 0 : old_trail_ptr . next = evens_list # stitch lists together return odds_list # return head of stiched lists else : trail_ptr . next = evens_list # stitch lists together return odds_list # return head of stiched lists","tags":"David","url":"/blog/2020/05/15/328-odd-even-linked-list-david/","loc":"/blog/2020/05/15/328-odd-even-linked-list-david/"},{"title":"86 Partition List (David)","text":"This code solves the Partition List problem. 1 2 3 4 5 6 7 8 9 10 Given a linked list and a value * x * , partition it such that all nodes less than * x * come before nodes greater than or equal to * x * . You should preserve the original relative order of the nodes in each of the two partitions . ** Example : ** ``` Input : head = 1 -> 4 -> 3 -> 2 -> 5 -> 2 , x = 3 Output : 1 -> 2 -> 2 -> 4 -> 3 -> 5 ``` The following is an explanation of my implemention of the two-pointer solution given by LeetCode. My initial attempt (at the bottom of this post) only worked for lists of length greater than 3 and didn't pass the submission after multiple revisions, and it relied on 6 pointers, rather than 2. LeetCode's Two-Pointer Solution For a more in depth explanation, check the solution here . The trick I learned from this problem is that lists can be grown in the direction they point without loosing the head, if you save it at the beginning as is done on lines 20 and 21 below. After all is said and done, a list that starts out with the following arrangement: 1 1 -> 2 -> 2 -> 4 -> 3 -> 2 -> None Will have a pointer arrangement that looks like this: 1 2 3 4 5 6 7 8 9 10 11 ltx_head | | gtx_head | | | | | +-----------+ +---------+ v v | v 1 -> 2 -> 2 4 -> 3 2 None | &#94; | | +--------------+ After this, gtx_head can be stiched to the back of ltx_head to return the final answer. Here's the code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution ( object ): def partition ( self , head , x ): \"\"\" :type head: ListNode :type x: int :rtype: ListNode \"\"\" #ltx = \"less than x\" #gtx = \"greater than (or equal to) x\" #ltx_head.next and gtx_head.next will still point to # heads of lists afer ltx and gtx have been incremented ltx = ltx_head = ListNode ( 0 ) gtx = gtx_head = ListNode ( 0 ) while head : if head . val < x : ltx . next = head ltx = ltx . next else : gtx . next = head gtx = gtx . next head = head . next gtx . next = None ltx . next = gtx_head . next return ltx_head . next My Original Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution : def partition ( self , head : ListNode , x : int ) -> ListNode : if not head : return if not head . next : return head trail = trail_ltx = head mid = mid_ltx = head . next lead = lead_ltx = head . next . next while mid : print ( head ) if mid . val < x : trail_ltx . next = mid mid . next = mid_ltx trail . next = lead trail_ltx = mid mid_ltx = mid . next trail = mid mid = lead lead = None if not lead else lead . next return head","tags":"David","url":"/blog/2020/05/15/86-partition-list-david/","loc":"/blog/2020/05/15/86-partition-list-david/"},{"title":"160 Intersection of Two Linked Lists (Kieran)","text":"Write a program to find the node at which the intersection of two singly linked lists begins. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def getIntersectionNode ( self , headA : ListNode , headB : ListNode ) -> ListNode : visited = set () while headA or headB : if headA : if headA in visited : return headA else : visited . add ( headA ) headA = headA . next if headB : if headB in visited : return headB else : visited . add ( headB ) headB = headB . next return None","tags":"Kieran","url":"/blog/2020/05/15/160-intersection-of-two-linked-lists-kieran/","loc":"/blog/2020/05/15/160-intersection-of-two-linked-lists-kieran/"},{"title":"328 Odd Even Linked List (Kieran)","text":"Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. My idea is to construct a list containing all of the even nodes of the list, while removing these nodes from the original list After this seconday list is made, it is tacked to the end of the original list which had its even number removed 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def oddEvenList ( self , head : ListNode ) -> ListNode : #head is the odd list #build the even list and tack it to the end if head is None : return head if head . next is None : return head even = True l_odd = head l_even = ListNode () even_head = l_even chaser = head head = head . next while head : if even : chaser . next = head . next even_head . next = head even_head = even_head . next chaser2 = chaser chaser = head head = head . next even = not even even_head . next = None if not even : chaser2 . next = l_even . next else : chaser . next = l_even . next return l_odd","tags":"Kieran","url":"/blog/2020/05/15/328-odd-even-linked-list-kieran/","loc":"/blog/2020/05/15/328-odd-even-linked-list-kieran/"},{"title":"430. Flatten a Multilevel Doubly Linked List (Kieran)","text":"You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below. Iterate down the list. If there's a child then put head.next on the stack, and make head.next = head.child, then continue iterating When you reach the end of the list, if there is still a node in the stack, make that node next and continue iterating. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \"\"\" # Definition for a Node. class Node: def __init__(self, val, prev, next, child): self.val = val self.prev = prev self.next = next self.child = child \"\"\" class Solution : def flatten ( self , head : 'Node' ) -> 'Node' : nodes = [] ret = head while head : if head . child : if head . next : #Only put another node in the stack if next exists nodes . append ( head . next ) head . next = head . child #Make the next node the child head . child = None head . next . prev = head #Connect backwards for doubly linked list elif head . next is None and nodes : #print(nodes) head . next = nodes . pop () #Pop the top of the stack into next head . next . prev = head #Connect backwards for doubly linked list head = head . next return ret","tags":"Kieran","url":"/blog/2020/05/15/430-flatten-a-multilevel-doubly-linked-list-kieran/","loc":"/blog/2020/05/15/430-flatten-a-multilevel-doubly-linked-list-kieran/"},{"title":"141 Linked List Cycle (David)","text":"This code solves the Linked List Cycle problem. If the hare (a pointer) starts ahead of the turtle (also a pointer) and the hare ends up passing the turtle from behind, then we know there must have been a cycle in the race course (the linked list). This is a Two-Pointer problem. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 141. Linked List Cycle # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution : def hasCycle ( self , head : ListNode ) -> bool : if not head or not head . next : return False hare = head . next turtle = head while hare and hare . next : if hare . next == turtle or turtle == hare : return True else : turtle = turtle . next hare = hare . next . next return False","tags":"David","url":"/blog/2020/05/11/141-linked-list-cycle-david/","loc":"/blog/2020/05/11/141-linked-list-cycle-david/"},{"title":"2 Add Two Numbers (David)","text":"This is the answer to the Add Two Numbers - LeetCode problem. Please don't use it; the solution is very very inefficient. Here are some reasons this code sucks: Do three separate pass throughs on l1, l2 and creating a linked list from their integer sum digit.val * (radix ** index_a) is a very expensive operation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : radix = 10 running_sum = 0 # iteratively sum l1 digit = l1 index_a = 0 while digit : running_sum += digit . val * ( radix ** index_a ) digit = digit . next index_a += 1 l1_sum = running_sum # iteratively sum l2's digits to l1 for running_sum digit = l2 index_b = 0 while digit : running_sum += digit . val * ( radix ** index_b ) digit = digit . next index_b += 1 total_sum = running_sum ret_list = None if not running_sum >= ( radix ** index_a ) or not running_sum >= ( radix ** index_b ): index = max ( index_a - 1 , index_b - 1 ) else : index = max ( index_a , index_b ) # create the return list while index >= 0 : digit = total_sum // ( radix ** index ) print ( total_sum , '//' , ( radix ** index ), '=' , digit ) total_sum = total_sum % ( radix ** index ) index -= 1 ret_list_old = ret_list ret_list = ListNode ( digit ) ret_list . next = ret_list_old return ret_list","tags":"David","url":"/blog/2020/05/11/2-add-two-numbers-david/","loc":"/blog/2020/05/11/2-add-two-numbers-david/"},{"title":"206 Reverse Linked List (David)","text":"This problem is taken from Reverse Linked List . Here I present recursive and iterative solutions. Recursive Solution The intuition for the recursive solution is as follows: Suppose our list looks like this 1 1 -> [2 -> 3 -> 4 -> 5 -> ...] where the first element of the linked list is called head and the the bracketed portion of the linked list, which I call the rest . The way we construct a reversed linked list from the head and the rest by the following process: First, run the reverse function on the rest . rev_head will point to the head of the already reversed portion of the list, and rev_tail will point to the tail of this portion. 1 2 3 1 -> [n -> ... -> 5 -> 4 -> 3 -> 2] | | | head rev_head rev_tail Then place the rest in front of the head by assigning rev_tail.next = head and head.next = None . 1 2 3 [n -> ... -> 5 -> 4 -> 3 -> 2] -> 1 -> None | | | rev_head rev_tail head The list is now fully reversed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 206. Reverse Linked List class Solution : def reverseList ( self , head : ListNode ) -> ListNode : # edge case of empty linked list if not head : return # single node is our base case if head . next == None : return head # inductive step else : #this call to reverseList() does not reverse in-place ... rev_head = self . reverseList ( head . next ) # ... which means we still have access to head.next here rev_tail = head . next head . next = None rev_tail . next = head return rev_head Iterative Solution In the iterative solution, the intuition is to itertively take the head off the original linked list and make it the head of another linked list using the insert function for linked lists. 1 2 3 4 def insert ( linked_list , node_val ): n = ListNode ( vanode_vall ) n . next = linked_list return n Here's a worked example that lends some intuition to the process, starting with a normal linked list. 1 2 3 1 -> 2 -> 3 -> 4 -> 5 -> None | head We then increment head and use ptr to make the head of the original linked list the head of a new linked list. 1 2 3 4 5 6 7 8 1 -> 2 -> 3 -> 4 -> 5 -> None | | ptr head None <- 1 2 -> 3 -> 4 -> 5 -> None | | ptr head And so on, with the remaning nodes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 None <- 1 <- 2 3 -> 4 -> 5 -> None | | ptr head None <- 1 <- 2 <- 3 4 -> 5 -> None | | ptr head None <- 1 <- 2 <- 3 <- 4 5 -> None | | ptr head None <- 1 <- 2 <- 3 <- 4 <- 5 None | | ptr head Then return ptr and you get your reversed linked list. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def reverseList ( self , head : ListNode ) -> ListNode : if not head : return if not head . next : return head prev_ptr = None while head : ptr = head head = head . next ptr . next = prev_ptr prev_ptr = ptr return ptr","tags":"David","url":"/blog/2020/05/11/206-reverse-linked-list-david/","loc":"/blog/2020/05/11/206-reverse-linked-list-david/"},{"title":"237 Delete Node in a Linked List (David)","text":"Usually, when deleting nodes in a linked list, we start with the head, and search for the node to delete. Once found, we usually delete the node with some pointer manipulation according to the dummy head technique . However , the Delete Node in a Linked List problem is slightly different; it instructs us to start in the middle of the linked list with node , and delete that element. We don't start at the head of the list or use the dummy head technique, as is normally the case. To delete node starting from node itself, we use the strategy of overwriting the value of node and shifting each of the values of the remaining to the right. Here's a worked example for deleting the node with value 2 in linked list 1 -> 2 -> 3 -> 4 -> 5-> None . This is the linked list we start with 1 2 3 4 1 -> 2 -> 3 -> 4 -> 5-> None | ptr (node) We then proceed thrugh the while loop, overwriting ptr.val with ptr.next.val . Here we overwrote 2 with 3 . 1 2 3 1 -> 3 -> 3 -> 4 -> 5-> None | | ptr ptr.next Now, we overwrite 3 with 4 . 1 2 3 1 -> 3 -> 4 -> 4 -> 5-> None | | ptr ptr.next After that, we exit the while loop, because we're close enough to the tail of the list to put the final elements in place; shift the final element of the link list over to the left by overwriting 4 with 5 , then overwrite the last 5 with None . 1 2 3 4 5 6 7 8 1 -> 3 -> 4 -> 5 -> 5 -> None | | ptr ptr . next 1 -> 3 -> 4 -> 5 -> None | | ptr ptr . next Finally, the code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 237. Delete Node in a Linked List # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution : def deleteNode ( self , node ): \"\"\" :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. \"\"\" ptr = node while ptr . next . next : ptr . val = ptr . next . val ptr = ptr . next ptr . val = ptr . next . val ptr . next = None","tags":"David","url":"/blog/2020/05/11/237-delete-node-in-a-linked-list-david/","loc":"/blog/2020/05/11/237-delete-node-in-a-linked-list-david/"},{"title":"2 Add Two Numbers (Kieran)","text":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. First, let's outline what's going on here. Two numbers are given in a linked list representation s.t. each node is a digit . The list is ordered s.t. the head is the least significant digit, and the tail is the least significant. Example: Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8 Explanation: 342 + 465 = 807. 1 2 3 4 #We put the head to the right to follow convention for digits l1 = ( 3 <- 4 <- 2 ) l2 = ( 4 <- 6 <- 5 ) l1 + l2 = ( 8 <- 0 <- 7 ) Solution using ‘pen and paper' math The name comes from how similar this looks to addition on paper. Lets review addition, we start from the righthand side, adding down, carry over, then repeat. 1 2 3 4 1 342 +465_ 807 We can use this as inspiration for our solution. Our solution breaks down like this then: Add a single digit Carry Repeat We're going to progressively work towards the solution together, so follow along. Here's our first attempt: 1 2 3 4 5 6 7 8 class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : lsum = l1 while l1 and l2 : l1 . val += l2 . val l1 = l1 . next l2 = l2 . next return lsum Isn't that pretty? Just add each node together and store the result into l1. This is severely incomplete, but this is really the essense of the solution. In fact, this covers a lot of the test cases. We just need to work out the kinks. First and most obviously, what if you get a number that overflows, i.e. greater than 9. From the example input we have 6+4 = 0, carry 1. Our first attempt just gets 10. :( Here's our next attempt: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : #We start with 0 in the carry carry = 0 lsum = l1 #Repeat while l1 and l2 aren't empty while l1 and l2 : l1 . val += l2 . val #Add the carry and reset it to zero l1 . val += carry carry = 0 if l1 . val >= 10 : #cut off the 1 infront of the digit, and set carry l1 . val %= 10 carry = 1 l1 = l1 . next l2 = l2 . next return lsum Now we have something of substance. We've accounted for the carry sufficiently, and if we add the constraint \"l1 and l2 are the same length\" then our attempt works! Sadly, no such constraint exists and we have to add code to allow for lists of differing lengths. Lets refer back to how this looks on pen and paper 1 2 3 100342 100342 + 465_ is + 000465_ 100807 100807 If you think about it… The white space can just be a bunch of trailing zeroes. And we know that any number plus zero is itself. More formally, 1 2 let n be a number n + 0 = n Zero is also known as the additive identity because of this property, and we can use this. Basically all we have to do is \"add\" a bunch of zeroes to the rest of the number, and doing this means doing nothing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : #We start with 0 in the carry carry = 0 lsum = l1 #Repeat while l1 and l2 aren't empty while l1 and l2 : l1 . val += l2 . val #Add the carry and reset it to zero l1 . val += carry carry = 0 if l1 . val >= 10 : #cut off the 1 infront of the digit, and set carry l1 . val %= 10 carry = 1 #temp follows l1 so it can be at the tale of l1 at the end of the while loop temp = l1 l1 = l1 . next l2 = l2 . next #Case where there are still digits in l1 if l1 : temp = temp #Case where l2 still has digits if l2 : temp . next = l2 l1 = temp . next return lsum What's going on here is temp actually represents the rest of the digits we have yet to add. Both cases after the while loop just tack these onto the end of l1 , effectively adding them. Genius, right? Not quite. There's still the annoying case of there being a carry at the last digit that wasn't trailing. The worst case example of this is as follows: 1 2 3 9999 + 1 10000 Our code erroneously does this: 1 2 3 9999 + 1 9990 To fix this, we need to add a second while loop that cascade carries down the remainder of l1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : #We start with 0 in the carry carry = 0 lsum = l1 #Repeat while l1 and l2 aren't empty while l1 and l2 : l1 . val += l2 . val #Add the carry and reset it to zero l1 . val += carry carry = 0 if l1 . val >= 10 : #cut off the 1 infront of the digit, and set carry l1 . val %= 10 carry = 1 #temp follows l1 so it can be at the tale of l1 at the end of the while loop temp = l1 l1 = l1 . next l2 = l2 . next #Case where there are still digits in l1 if l1 : temp = temp #Case where l2 still has digits if l2 : temp . next = l2 l1 = temp . next #Loop while l1 isn't empty while l1 : #Add the carry l1 . val += carry carry = 0 #If it overflows, reset the carry if l1 . val >= 10 : l1 . val %= 10 carry = 1 #Same as before, 'chase' l1 with temp temp = l1 l1 = l1 . next #If there's still a carry, tack it to the end if carry == 1 : temp . next = ListNode ( val = 1 ) return lsum And with that we finally have an accepted solution! Thank you for reading. Please","tags":"Kieran","url":"/blog/2020/05/11/2-add-two-numbers-kieran/","loc":"/blog/2020/05/11/2-add-two-numbers-kieran/"},{"title":"Add Two Numbers","text":"This post will cover my solution in Python 3 for LeetCode's Add Two Numbers problem. The problem wants us to add two numbers ( l1 and l2 that are encoded as linked lists, such that each digit is a linked list node. In this scheme, the digits in the linked list are ordered from least significant to most signficant. Thus, the number 254 would be represented as the linked list 4 -> 5 -> 2 -> None . The general approach to the problem that I took was to loop through the lists, pairwise add the digits of l1 and l2 and insert them as new nodes into a return list. I'll walk through my solution with some annotated code snippets. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def addTwoNumbers ( self , l1: ListNode , l2: ListNode ) -> ListNode: # Use dummy head technique as a starting point for the algorithm head = ListNode ( \"dummy\" ) current = head # Iterate through the lists until _both_ are None # This means, even if one is shorter than the other, keep looping anyway while l1 or l2: # Default to \"0\" if one of the lists is out of digits val1 = l1 . val if l1 else 0 val2 = l2 . val if l2 else 0 # Compute the sum of the two digits for the result digit digit = val1 + val2 # Move a carry by adding 1 to the next node in l1 or l2 -- depending on which one actually has a \"next\" node available # If neither l1 or l2 have a next node available, (for example, you are carrying past the final digit of the longer l1/l2) # then just create a new node and append it to the end if digit >= 10 : node = l1 if l1 else l2 if node . next: node . next . val += 1 else: node . next = ListNode ( 1 ) temp = ListNode ( digit % 10 ) # Put this digit as a node into our result list # Move the result list forward current . next = temp current = current . next # Move l1 and l2 forward, for as long as they have a \"next\" l1 = l1 . next if l1 else None l2 = l2 . next if l2 else None # Return the next to exclude our dummy head from the beginning return head . next","tags":"Alex","url":"/blog/2020/05/10/add-two-numbers/","loc":"/blog/2020/05/10/add-two-numbers/"},{"title":"Stacks, Queues, Heaps, and Hash Tables in Python","text":"Many interview problems that rely on stacks, queues, and hash tables, could be made easier by importing some python libraries that I rarely use. Most of these are in sections 8.3: collections , and 8.4 : heapq , in the Python documentation. Stacks ( docs ) First, just for reference, here is the way to implement a python stack using a list: 1 2 3 stack = [ 1 , 2 , 3 ] # a list named \"stack\" stack . append ( 4 ) # just use regular list append to add something to the stack stack . pop () # removes the last element of our list named stack Pretty simple. Just remember that, while pop() is a list method in python, push() isn't. Priority Queue or Heap ( docs ) There isn't a purpose-built heap class in python. Like stacks, python heaps are implemented using a list. However, the methods for pushing, and popping and reheapifying aren't standard list methods, so they have to be imported. 1 2 3 4 5 import heapq heap = [ 21 , 1 , 45 , 78 , 3 , 5 ] # a python list named \"heap\" heapq . heapify ( heap ) # run heapify on our list named heap heapq . heappop ( heap ) # heappop pops one element off and reheapifies the list heapq . heappush ( heap , 8 ) # heappush appends 8 and reheapifies the list Queues ( docs ) The queue must have it's own class, because removing items from the front of a python list takes O(n) time. Each and every list element has to be moved once to the left, should the first list element be removed. I'm not certain as to why this is, since I had always thought that the underlying implementation of a python list was a linked list with indexed, random access pointers to each list element. At any rate, the deque class, which implements the queue data structure in python, has enqueue and dequeue operations that are both O(1). 1 2 3 4 5 6 7 8 9 10 import collections.deque queue = deque ([ \"Mon\" , \"Tue\" , \"Wed\" ]) # create deque named \"queue\" from list # enter on right, leave on left queue . append ( \"Thu\" ) # Append to the right queue . popleft () # Remove from the left (removes Mon) # enter on left, leave on right queue . appendleft ( \"Sun\" ) # append to the left queue . pop () # Remove from the right The deque class implements a two sided queue. You enter from the left or the right. Consequentially, you can also implement a stack from the deque class. Dictionary or Hashtable The Dictionary Suppose you have a string s . You can keep a tally of the number of letters of each kind in the word with a Python dictionary. 1 2 3 4 5 6 7 s = \"letters\" d = {} for char in s : if char in d : #check if the character exists in the dictionary d [ char ] += 1 #if it does, increment else : d [ char ] = 1 #if not, initialize to 1 Counter Objects ( docs ) Counters are a subclass of dictionaries, designed to keep tallies. You can pass any iterable and each element in the iterable (letters in a string, elements in a list, items in a dictionary.) Basically a Counter is a dictionary, but 1 2 3 4 5 6 7 8 # normal dictionary d = {} d [ 'a' ] # returns KeyError: 'a' # counter dictionary from collections import Counter c = Counter () c [ 'a' ] # initializes a dictionary element with default value of {'a': 0} AND returns 0 Here is how you would take a tally using Counter . 1 2 3 # Tally occurrences of words in a list cnt = Counter ([ 'red' , 'blue' , 'red' , 'green' , 'blue' , 'blue' ]) cnt . most_common () # returns list of tuples with count [('blue', 3), ('red', 2), ('green', 1)] Default Dictionary ( docs ) Like the Counter objects, defaultdict objects do not return key errors. Default dictionaries allow you to pass a lambda function as an argument that will be run whenever a value can't be found for a given key. 1 2 dd = defaultdict ( lambda : None , {}) # this default dict creates key:None in dictionary whenever key doesn't already exist dd [ 'a' ] # returns None instead of KeyError","tags":"David","url":"/blog/2020/05/10/stacks-queues-heaps-and-hash-tables-in-python/","loc":"/blog/2020/05/10/stacks-queues-heaps-and-hash-tables-in-python/"},{"title":"242 Valid Anagram (David)","text":"The posts in this series (each with the tag Bloomberg ) contain problems taken from this list of Bloomberg phone interview problems. In this post, we solve LeetCode's 242 Valid Anagram . Given two strings s and t , write a function to determine if t is an anagram of s. First, it's important to know the difference between an anagram and a palindrome. An anagram is a word formed by rearranging the letters of another word. So if string s is \"tarp\" and string t is \"part\", then s and t are anagrams of one another. On the other hand, A palindrome is a word that reads the same backward or forward (like the word \"kayak\"). There are a couple of ways to tackle this problem. Each approach involves creating a dictionary where the letters from s and t are keys and the values are counts of how many times the letters occur in the string. Whenever we create a tally dictionary in Python, we have to be cognizant of avoiding KeyError s. The first approach relies on python's .get() method to avoid this, while the last two methods rely on the Python's collections classes. Solution using Dictionary and .get() In Python, the get(key, default) method returns a value for the given key in a dictionary. If key is not available, the method then returns default . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def isAnagram ( self , s : str , t : str ) -> bool : # if strings are not same length, # they can't be anagrams if len ( s ) != len ( t ): return False # create default dictionaries for for s and t s_dict = {} t_dict = {} # populate dictionaries for for s and t # where the letters are keys and the number of times # the letter appears are values for s_char in s : # if s_dict[s_char] doesn't exist yet, # initialize to 1. Otherwise increment by 1 if not s_dict . get ( s_char ): s_dict [ s_char ] = 1 else : s_dict [ s_char ] += 1 for t_char in t : if not t_dict . get ( t_char ): t_dict [ t_char ] = 1 else : t_dict [ t_char ] += 1 return t_dict == s_dict Solution using collections.defaultdict The defaultdict class is covered in the Stacks, Queues, Heaps, and Hash Tables in Python post. Where a Python dictionary normally throws a KeyError if you try to retrieve a value with a key that is not in the dictionary, defaultdict will just create a new key-value pair with a default value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from collections import defaultdict class Solution : def isAnagram ( self , s : str , t : str ) -> bool : # if strings are not same length, # they can't be anagrams if len ( s ) != len ( t ): return False # this default dict makes values default to 0 (int's default) # when any accessed key doesn't already exist in the dictionary s_dict = defaultdict ( int ) t_dict = defaultdict ( int ) # populate default dictionaries for for s and t # where the letters are keys and the number of times # the letter appears are values for s_char in s : s_dict [ s_char ] = s_dict [ s_char ] + 1 for t_char in t : t_dict [ t_char ] = t_dict [ t_char ] + 1 return t_dict == s_dict Solutions using collections.Counter Like defaultdict , the Counter class is also a subclass of Python Dictionary. It's a class designed to keep tallies, like we are doing here. 1 2 3 4 5 6 7 8 9 10 11 12 from collections import Counter class Solution : def isAnagram ( self , s : str , t : str ) -> bool : if len ( s ) != len ( t ): return False # in one step, we instantiate two dictionaries # that each contain tallies of letters in s and t # and we compare if those tally dictionaries are equal return Counter ( s ) == Counter ( t )","tags":"David","url":"/blog/2020/05/10/242-valid-anagram-david/","loc":"/blog/2020/05/10/242-valid-anagram-david/"},{"title":"Week 1 Excercises","text":"Goals This week we will be covering the fundamentals of linked lists and common ways they appear in interviews. Easily build a linked list Understand most common variants Feel comfortable with recursion Two pointer technique Dummy head technique Comfort with pointer bookkeeping Framework for approaching Linked List problems Monday Read the Linked List Codepath Wiki Article Read about the Dummy Head , Multiple Pass , and Two-Pointer linked list design patterns. Solve the following problems (shoot for 30-90 minutes in total) Delete Node in a Linked List - LeetCode Reverse Linked List - LeetCode Linked List Cycle - LeetCode Add Two Numbers - LeetCode Wednesday Read the UMPIRE method post here and follow the steps (Understand, Match, Prototype, Implement, Review, and Evaluate) as you solve the problems. Take special care to match based on the linked list designed patterns learned on Monday, and to sketch visualizations / write pseudo code on a notepad near your computer. Pointer Bookeeping (demonstrated in this lecture ) can be a helpful tool for linked list diagramming. Also, for a refresher on how pointers work in python read this article on python variables and memory management and/or this passage about simulating pointers in python . Odd Even Linked List - LeetCode Swap Nodes in Pairs - LeetCode Rotate List - LeetCode Partition List - LeetCode Add Two Numbers II - LeetCode Saturday Merge Two Sorted Lists - LeetCode Intersection of Two Linked Lists - LeetCode Copy List with Random Pointer - LeetCode Linked List Cycle II - LeetCode Remove Duplicates from Sorted List II - LeetCode Reorder List - LeetCode Merge k Sorted Lists - LeetCode","tags":"Weekly Lessons","url":"/blog/2020/05/09/week-1-excercises/","loc":"/blog/2020/05/09/week-1-excercises/"}]};